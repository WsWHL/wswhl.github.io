[{"title":"解决centos dnf自动更新异常问题","url":"/2023/05/10/centos-dnf-makecache/","content":"起因最近发现代理服务总是出现莫名中断不可访问的异常问题，刚开始怀疑是机器搭建的服务太多导致内存占用过高导致的，于是用top命令查了一下占用最多的服务也就200Mb，总共占用也就百分之六七十，不应该导致服务崩溃，于是又查询了一下系统日志才发现端倪.\n\n\n问题排查查询系统错误和警告日志：\njournalctl -p err..alert\n\nkernel: Out of memory: Killed process 1813 (dnf) total-vm:842700kB, anon-rss:259464kB, file-rss:0kB, shmem-rss:0kB, UID:0 pgtables:1236kB oom_score_adj:0systemd[1]: Failed to start dnf makecache.\n\n原来是由于dnf软件包信息更新导致的系统OOM崩溃.\n解决方案由于主机内存有限（1G）, 于是只能选择先禁用，优先保证服务正常运转.\n禁用定时服务：\nsystemctl stop dnf-makecache.timersystemctl disable dnf-makecache.timer","categories":["每日一记"],"tags":["linux"]},{"title":"ClasshX协议配置","url":"/2023/10/13/classhx-protocol/","content":"VLESS- name: &lt;名称&gt;  type: vless  server: &lt;服务地址&gt;  port: &lt;服务端口&gt;  uuid: &lt;标识ID&gt;  alterId: 64  cipher: auto  udp: true  network: ws  sni: &lt;服务地址&gt;  tls: true  ws-opts:    path: /&lt;回退路径&gt;    headers:      Host: &lt;服务地址&gt;"},{"title":"Python装饰器","url":"/2020/04/05/decorator/","content":"理解装饰器，顾名思义就是用来包装的，在表面进行修饰的方式。\n装饰器本身就是一种函数或类，返回值同样也是函数或类。它的意义主要在于无需对原有代码进行修改的前提下添加一些额外的功能，采用一种切面编程思想，比如常用的应用场景日志记录、性能测试、事物处理、权限校验、缓存等功能。有了装饰器我们能够尽可能的重用代码，避免大量重复代码，有效的规避规避对现有业务代码进行改动导致新的产生。\n\nDemo本文主要演示手动实现和采用Python语法糖实现方式。\n手动实现1.简单函数调用\ndef test(func):  print(&#x27;begin execution func.&#x27;)  func()  print(&#x27;func execution ends.&#x27;)  def hello():  print(&#x27;hello.&#x27;)  test(hello)\n\n打印输出：\n\nbegin execution func.\nhello.\nfunc execution ends.\n\n2.日志记录\nimport timedef logger(func):  def wrapper():    print(&#x27;[%d]start run %s.&#x27; % (int(time.time()), func.__name__))    return func()  return wrapperdef test():  print(&#x27;wait 10 seconds.&#x27;)  time.sleep(10)  hello = logger(test)hello()\n\n打印输出：\n\n[1563619707]start run test.\nwait 10 seconds.\n\n上面例子中，logger函数中的wrapper函数将原test函数包装后返回，最后调用执行。\n@ 语法糖如果你了解Python语法，一定看到或使用过@符号，@就是Python中装饰器的语法糖。使用时反正目标函数定义的地方，这样即可省略掉赋值的过程。\n1.无参装饰器\nimport timedef logger(func):  def wrapper():    print(&#x27;[%d]start run %s.&#x27; % (int(time.time()), func.__name__))    return func()  return wrapper@loggerdef test():  print(&#x27;wait 10 seconds.&#x27;)  time.sleep(10)  test()\n\n打印输出：\n\n[1563621964]start run test.\nwait 10 seconds.\n\n以上例子采用装饰器的方式可以无侵入性的添加或实现额外的功能。\n2.带参目标函数装饰器写法\n\n单个参数\ndef logger(func):  def wrapper(name):      print(&#x27;start run %s&#x27; % func.__name__)      return func(name)  return wrapper@loggerdef test(name):    print(&#x27;my name %s&#x27; % name)test(&#x27;this blog&#x27;)\n\n多个参数\ndef logger(func):  \tdef wrapper(*args):  \t\tprint(&#x27;start run %s&#x27; % func.__name__)    \treturn func(*args)  return wrapper@loggerdef test(name, age):  \tprint(&#x27;my name %s,age %d&#x27; % (name, age))  test(&#x27;this blog&#x27;, 1)\n\n\n\n关键字参数\ndef logger(func):  \tdef wrapper(*args, **kwargs):  \t\tprint(&#x27;start run %s&#x27; % func.__name__)    \treturn func(*args, **kwargs)  return wrapper@loggerdef test(name, age, phone=None, address=None):  \tprint(&#x27;my name %s,age %d,phone %d,address %s&#x27; % (name, age, phone, address))  test(&#x27;this blog&#x27;, 1, phone=124334, address=&quot;test address&quot;)\n\n带参装饰器\ndef logger(level):  def decorator(func):        def wrapper(*args, **kwargs):      print(&#x27;[%s]start run %s&#x27; % (level, func.__name__))    \treturn func(*args, **kwargs)  \treturn wrapper  return decorator@logger(level=&quot;INFO&quot;)def test(name, age, phone=None, address=None):  \tprint(&#x27;my name %s,age %d,phone %d,address %s&#x27; % (name, age, phone, address))  test(&#x27;this blog&#x27;, 1, phone=124334, address=&quot;test address&quot;)\n\n打印信息：\n\n[INFO]start run test\nmy name this blog,age 1,phone 124334,address test address\n\n带参装饰器返回的本就是一个装饰器，@logger(level=&quot;INFO&quot;)等同于decorator\n\n\n 3.类装饰器\n装饰器不仅仅可以是函数，也可是类。类装饰器具有更大的灵活性、高类聚、封装性等优点。类装饰器主要利用类的一个__call__方法实现，@形式装饰器附加到函数上时就会调用该方法。\n  一个对象为可调用对象callable时就会实现__call__方法 \n  import timeclass logger:    def __init__(self, func):    \tself.func = func    def __call__(self, *args, **kwargs):    \tprint(&#x27;[args]name %s, age %d&#x27; % *args)    \tprint(&#x27;start run %s:%d&#x27; % (self.func.__name__, int(time.time())))    \tself.func(*args, **kwargs)    \tprint(&#x27;%s running is complete:%d&#x27; % (self.func.__name__, int(time.time())))          @loggerdef test(name, age):  \tprint(&#x27;my is name %s, age %d&#x27; % (name, age))    print(&#x27;wait 10 seconds.&#x27;)    time.sleep(10)test(&#x27;this blog&#x27;, 1)\n\n  打印输出：\n\n[args]ame this blog, age 1\nstart run test:1563626058\nmy is name this blog, age 1\nwait 10 seconds.\ntest running is complete:1563626068\n\n  在执行带参目标函数时，参数会传递给类装饰器的__call__方法，然后我们将参数传递给目标方法执行。\n4.多个装饰器使用\n一个函数可以同时使用多个装饰器，执行顺序为由内而外。\n@func3@func2@func1def test():  pass# 等效使用方式func = func3(func2(func1(test)))\n","categories":["Python"],"tags":["装饰器"]},{"title":"Elasticsearch parent child索引构建","url":"/2020/04/05/es-parent-child/","content":"注意事项\n我们在使用es查询客户端时，需要注意客户端版本是否与服务端版本兼容，因为不同版本所生成的查询语法可能会有很大的差别，以至于出现查询异常，或完全无效的情况，所以要使用对应版本和对应语法编写。\n有些特殊的查询语法，对索引的创建方式严格的要求，且无法直接在创建后去进行修改实现。例如：默认字段查询时是以Match分词进行匹配，如果要使用term查询方式，则需要将对于字段设置为keyword类型，某则该查询语法无效，或者匹配到不完全一致的结果，部分特殊字段也需要特殊处理，比如ip、邮箱、编号等这一类。\nParent Child Query结构，只能建立一种文档关联关系，从而避免一个文档冗余数据太多影响查询效率。\n\nParent Child Query创建索引这里就简单的使用es官网的一个例子。\n\n编写模型类\n  public abstract class MyDocument&#123;\tpublic int Id &#123; get; set; &#125;\tpublic JoinField MyJoinField &#123; get; set; &#125;&#125;public class MyParent : MyDocument&#123;\t[Text]\tpublic string ParentProperty &#123; get; set; &#125;&#125;public class MyChild : MyDocument&#123;\t[Text]\tpublic string ChildProperty &#123; get; set; &#125;&#125;public class MyChild1 : MyDocument&#123;\t[Text]\tpublic string ChildProperty &#123; get; set; &#125;&#125;\n\n创建索引\nvar createIndexResponse = client.Indices.Create(&quot;index&quot;, c =&gt; c    .Index&lt;MyDocument&gt;()    .Map&lt;MyDocument&gt;(m =&gt; m        .RoutingField(r =&gt; r.Required())         .AutoMap&lt;MyParent&gt;()         .AutoMap&lt;MyChild&gt;() \t\t.AutoMap&lt;MyChild1&gt;()        .Properties(props =&gt; props            .Join(j =&gt; j                 .Name(p =&gt; p.MyJoinField)                .Relations(r =&gt; r                    .Join&lt;MyParent&gt;(typeof(MyChild), typeof(MyChild1))                )            )\t\t\t.Keyword(s =&gt; s.Name(f =&gt; f.Id))\t\t\t.Keyword(s =&gt; new KeywordPropertyDescriptor&lt;MyChild1&gt;().Name(f =&gt; f.ChildProperty))        )    ));\n*** 查询索引映射信息：/index/_mapping，所以要想修改索引映射信息只能删除重建 ***\n\n\n查询主要有四种查询方式：\n\nParent Id Query\nq.ParentId(p =&gt; p    .Type&lt;MyDocument&gt;()    .Id(MyParent.Id))\n\n可以根据父Id，找出所有相关的子类型数据。\n\n\nHas Parent Query\nq.HasParent&lt;MyParent&gt;(c =&gt; c    .Query(qq =&gt; qq.MatchAll()))\n\n可以根据父类的相关属性匹配出对应关联的子类数据。\n\n\nHas Child Query\nq.HasChild&lt;MyChild&gt;(c =&gt; c    .MaxChildren(5)    .MinChildren(1)    .ScoreMode(ChildScoreMode.Average)    .Query(qq =&gt; qq.MatchAll()))\n\n可以根据子类的相关属性，匹配出子类关联的父类数据。\n\n\nFind JoinField Type\nq.HasRelationName&lt;MyParent&gt;(x =&gt; x.MyJoinField).MatchAll()\n\n可以根据指定JoinField类型筛选相关数据。\n\n 备注：查询时并不能像常规的关系型数据库进行联合查询，因此当我们需要根据父类型和子类型属性进行数据筛选时，最好将相关字段数据冗余到一个类型，这样可以方便的查询。\n\n\n","categories":["每日一记"],"tags":["Elasticsearch","Indexer"]},{"title":"hexo博客在线编辑同步服务hexon部署","url":"/2023/05/07/hexon-deploy/","content":"hexo框架是一个主题丰富, 内容简洁的轻量级静态博客框架. 但也正是如此在实际使用中缺陷也很明显, 那就是博客文章内容不方便管理, 每次编写好markdown文件还需要经过hexo命令编译打包推送等步骤, 虽然命令不多, 但体验很不好, 有种很明显的脱离感. 而hexon的出现很好的弥补了这些不足之处, 为hexon作者点个大大的赞👍!!!\n\n\n至此, 当我们部署hexon服务后我们可以实现如下效果:\n\n同步博客git内容, 实现在线编辑并推送, 配置好GitHub Action后可以自动触发部署\n通过hexon编辑博客文章后, 直接在我们的服务器进行打包部署, 编译好的内容将直接推送到GitHub仓库的gp-pages分支实现自动部署, 接管GitHub Action构建功能\n\n✨准备内容:\n\n💻一台公网vps服务器, 1G足矣\n🙎GitHub账号, 并初始化好hexo博客仓库\n👋Linux命令基础, 会动的小指头\n🤔️一颗善于思考的小脑瓜…\n\n项目依赖项git、pnpm、node、hexo\n\n安装pnpm包管理工具\nbash wget -qO- https://get.pnpm.io/install.sh | ENV=&quot;$HOME/.bashrc&quot; SHELL=&quot;$(which bash)&quot; bash -pnpm env use --global lts     # 安装node环境\n这里仅以linux 64位平台举例,具体平台参考官网: https://pnpm.io/installation\n\n拉取博客项目默认采用root用户,后续hexon服务拉取和提交博客代码均需要访问GitHub仓库,建议提前配置好服务器的ssh key访问配置, 确保git命令能正常操作仓库\ngit clone git@github.com:&lt;github_name&gt;/&lt;github_name&gt;.github.io.gitnpm install -g hexo-cli      # 安装hexo工具npm install      # 还原博客项目依赖hexo server   # 可检查博客服务是否能正常启动\n项目同步git时将与拉取分支保持一致, 部署时需要在_config.yml配置中添加如下gh-pages配置信息\n# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: git@github.com:&lt;github_name&gt;/&lt;github_name&gt;.github.io.git  branch: gh-pages\n\n\n拉取hexon项目并还原依赖, 初始化博客配置\ngit clone https://github.com/gethexon/hexon  # 拉取项目pnpm install     # 还原依赖项pnpm run setup       # 初始化博客项目路径等配置信息\n启动hexon服务\npnpm start\n默认配置监听本地5777端口,浏览器访问: http://localhost:5777\n\n\n进阶教程, 采用systemd部署\n创建hexon服务配置创建文件/etc/systemd/system/hexon.service并写入如下配置   [Unit]Description=Hexon ServiceAfter=network.target[Service]Environment=PATH=/root/.local/share/pnpm:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/binWorkingDirectory=/opt/hexon/serverType=simpleUser=rootGroup=rootRestart=on-failureRestartSec=5sExecStart=pnpm cross-env NODE_ENV=production node dist/index.jsLimitNOFILE=1048576[Install]WantedBy=multi-user.target\nWorkingDirectory: 设置为我们拉取hexon项目下的server文件夹, 启动命令会在该目录下执行User、Group: 服务执行用户信息, 尽量保持和我们在终端执行时的一致, 因为存在上下文依赖关系, 比如git拉取提交项目时需要ssh密钥授权等\n文件中PATH追加了pnpm环境路径/root/.local/share/pnpm很重要, 后续hexon需要执行该路径下的一些命令, 具体路径为我们安装pnpm时所使用的用户主目录下隐藏文件夹中\n\n\n启动hexon守护服务systemctl enable hexon     # 添加自启systemctl start hexon      # 启动服务\n\n启动后查看日志确认是否正常执行journalctl -u hexon -f\n\n\n\n关于hexon不足之处的几点建议:\n\n希望能够支持插入图片, 并能够配置图床(阿里云、腾讯云等文件存储服务).\n希望能够支持hexo项目设置项的可视化配置, 以此更加方便管理和配置\n希望登录授权支持双因子认证(2FA), 从而提高后台服务安全性\n其他内容待后续充分体验后补充…\n\n鸣谢项目hexon!!!\n","categories":["每日一记"],"tags":["linux","Blog","hexon","hexo"]},{"title":"2019年成都各区限购信息","url":"/2020/04/05/house-purchase/","content":"区域划分\n\n\n类别\n区域\n\n\n\nA类\n天府新区、成都直管区\n\n\nB类\n高新南部园区\n\n\nC类\n高新南部园区、锦江区、青羊区、金牛区、武侯区、成华区、龙泉驿区、新都区、温江区、双流区、郫都区\n\n\nD类\n青白江区、简阳市、都江堰市、彭州市、邛崃市、崇州市、金堂县、新津县、大邑县、浦江县\n\n\n\n\n关系说明单纯看只具备2年社保或者2年户口的话：　　1、A只能买A、D　　2、B只能买B、D　　3、A和B不能互买　　4、C可以买C、D，不能买A或B，C区域之间可以互买。　　5、D买D，不能买A、B、C，D区域之间可以互买。　　也就是说，现在如果把户口迁到天府新区，而工作单位又不在成都的话。想要买天府新区的房子就只有等两年后了。  提示：AB类区域是最严格的区域！不能买C类，但是可以买D类\n天府新区（A类区域）满足其一即可　　条件一：户口买房：天府新区户口　　新落户人群：额外需要12个月成都市社保（社保参保地不限定区域，但是工作单位注册地必须是天府新区）以及要有工作单位　　非新落户人群：有天府新区户口就行。\n　　条件二：社保买房：在没有户口的情形下，需要连续24个月单位社保（购房时单位注册地要在天府新区）　　前提：两人及以上本市户籍居民家庭在全市范围内无自有产权住房或只拥有1套自有产权住房，或本市户籍成年单身居民家庭、非本市户籍居民家庭在全市范围内无自有产权住房。\n高新南区（B类区域）满足其一即可　　条件一：户口买房：高新南区户口　　新落户人群：额外需要12个月成都市社保（社保参保地不限定区域，但是工作单位注册地必须是高新南）以及要有工作单位　　非新落户人群（指有2年以上户口）：有高新南区户口就行。\n　　条件二：社保买房：在没有户口的情形下，需要连续24个月单位社保（购房时单位注册地要在高新南区）　　前提：两人及以上本市户籍居民家庭在全市范围内无自有产权住房或只拥有1套自有产权住房，或本市户籍成年单身居民家庭、非本市户籍居民家庭在全市范围内无自有产权住房。\n高新西区为代表（C类区域）　　条件一：户口买房：C类区域户口可以　　新落户人群：额外需要12个月以上成都社保（单位注册地11区域就行，不同区域间社保时间可以叠加）以及要有工作单位\n　　非新落户人群：有C类区域户口　　条件二：社保买房：在没有户口的情形下，需要C类区域连续24个月单位社保（购房时单位注册地要在C类区域），注意D类区域户口的人，有C类区域24个月单位社保也可以买\n　　前提：两人及以上本市户籍居民家庭在全市范围内无自有产权住房或只拥有1套自有产权住房，或本市户籍成年单身居民家庭、非本市户籍居民家庭在全市范围内无自有产权住房。\n青白江区为代表（D类区域）　　条件一：　　户口买房：任意区域户口都行　　社保买房：任意区域连续12个月单位社保\n","categories":["每日一记"],"tags":["购房"]},{"title":"Linux日志查询命令journalctl使用手册","url":"/2023/05/10/linux-journalctl/","content":"对于采用systemd管理服务的系统下，默认存在systemd-journald日志服务，并提供了journalctl命令查询记录的日志信息。\n\n\n常用命令\n查询所有日志：journalctl\n查询内核日志：journalctl -k\n查询启动日志：journalctl -b\n查询最近20条日志：journalctl -n 20\n查询并跟踪日志：journalctl -f\n查询冲突、告警、错误日志：journalctl -p err..alert\n查询制定服务日志：journalctl -u caddy.service -u nginx.service\n查询指定进程日志：journalctl _PID=725\n\n根据时间查询命令\n查询20分钟前的日志：journalctl --since &quot;20 min ago&quot;\n查询今天的日志：journalctl --since today\n查询指定日期的日志：journalctl --until 2023-05-01\n\n","categories":["每日一记"],"tags":["linux"]},{"title":"解决Mac默认vim无法使用剪贴板问题","url":"/2020/04/05/mac-vim/","content":"开篇mac系统自带的vim属于阉割版，不支持一些功能，因此需要手动编译替换。查看默认vim版本及已启用功能：\nvim --version\n输出功能前面带符号+表示已启用该功能。例如：输出包含+clipboard表示支持剪贴板复制功能，否则不支持。\n\n源码编译\n下载源码源码地址：https://github.com/vim/vim/releases\ncurl -LJO https://github.com/vim/vim/archive/v8.2.0352.tar.gz\t#下载tar -zxvf vim-8.2.0352.tar.gz\t#解压\n\n设置编译参数需要支持的功能就在此处设置\n./configure --with-features=huge --enable-pythoninterp=yes  --enable-cscope --enable-fontset --enable-perlinterp --enable-rubyinterp --with-python-config-dir=/usr/lib/python2.7/config --prefix=/usr/local\n\n默认已启用剪贴板复制功能，所以不用设置\n\n\n编译和安装\nmake &amp;&amp; make install\n\n替换默认vim\necho &quot;alias vim=&#x27;/usr/local/bin/vim&#x27;&quot; &gt;&gt; ~/.zshrc #默认文件为.bash_profilesource ~/.zshrc\n\n","categories":["每日一记"],"tags":["Mac OS","Vim"]},{"title":".NET Core CLI命令","url":"/2020/04/05/netcore-cli/","content":"Consoledotnet [command] [arguments] [--additional-deps] [--additionalprobingpath] [--depsfile]    [-d|--diagnostics] [--fx-version] [-h|--help] [--info] [--roll-forward-on-no-candidate-fx]    [--runtimeconfig] [-v|--verbosity] [--version]\n\n查看可用模版：\ndotnet new -l\n\n例如创建一个MVC模版的项目：\ndotnet new mvc -lang c# -o my_web\n\ndotnet命令常规\n\n\n命令\n说明\n\n\n\ndotnet build\n生成 .NET Core 应用程序。\n\n\ndotnet clean\n清除生成输出。\n\n\ndotnet help\n显示命令更详细的在线文档。\n\n\ndotnet migrate\n将有效的预览版 2 项目迁移到 .NET Core SDK 1.0 项目。\n\n\ndotnet msbuild\n提供对 MSBuild 命令行的访问权限。\n\n\ndotnet new\n为给定的模板初始化 C# 或 F# 项目\n\n\ndotnet pack\n创建代码的 NuGet 包。\n\n\ndotnet publish\n创建代码的 NuGet 包。\n\n\ndotnet restore\n还原给定应用程序的依赖项。\n\n\ndotnet run\n从源运行应用程序。\n\n\ndotnet sln\n用于添加、删除和列出解决方案文件中项目的选项。\n\n\ndotnet store\n将程序集存储到运行时包存储区。\n\n\ndotnet test\n将程序集存储到运行时包存储区。\n\n\n项目引用\n\n\n命令\n说明\n\n\n\ndotnet add reference\n添加项目引用\n\n\ndotnet list reference\n列出项目引用\n\n\ndotnet remove reference\n删除项目引用\n\n\nNuGet 包\n\n\n命令\n说明\n\n\n\ndotnet add package\n添加NuGet包\n\n\ndotnet remove package\n删除NuGet包\n\n\nNuGet 命令\n\n\n命令\n说明\n\n\n\ndotnet nuget delete\n从服务器删除或取消列出包\n\n\ndotnet nuget locals\n清除或列出本地 NuGet 资源\n\n\ndotnet nuget push\n将包推送到服务器，并将其发布\n\n\n全局工具命令\n\n\n命令\n说明\n\n\n\ndotnet tool install\n在计算机上安装全局工具\n\n\ndotnet tool list\n列出当前安装在计算机上的默认目录中或指定路径中的所有全局工具。\n\n\ndotnet tool uninstall\n从计算机中卸载全局工具\n\n\ndotnet tool update\n在计算机上更新全局工具\n\n\n","categories":["C#",".NET Core"],"tags":["CLI"]},{"title":"优雅的Python代码就该这样写","url":"/2020/04/05/pythonic/","content":"简述Python本就是很高效的开发语言，相比其他语言而言已经很简洁明了。但在实际的编写中，往往会忽略这一点，本该用很简洁高效的写法实现，不仅能够为我们省去繁重的编写工作量，更能利于后期代码的可阅读性和维护。这里就列举一些常用的简洁高效的写法，反例就不在这里列举。\n\nPythonic1.变量交换\na = 1b = 2a, b = b, aprint(&#x27;a:%d, b:%d&#x27; % (a, b))\n打印输出：\n\na:2, b:1\n\n2.可迭代对象\nfor i in range(3):\tprint(i)\n打印输出：\n\n012\n\nrange是python3的写法，在python2中使用的是xrange\n3.带索引遍历\narr = [1, 3, 5, 7, 9]for i, num in enumerate(arr):\tprint(&#x27;index:%d, value:%d&#x27; % (i, num))\n打印输出：\n\nindex:0, value:1index:1, value:3index:2, value:5index:3, value:7index:4, value:9\n\n4.列表推导\narr = [i for i in range(10) if i % 2 == 0]print(arr)\n打印输出：\n\n[0, 2, 4, 6, 8]\n\n5.字符串拼接\nnames = [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;]print(&#x27;,&#x27;.join(names))\n打印输出\n\n张三,李四,王五\n\n6.zip创建键值对\nkeys = [&#x27;name&#x27;, &#x27;sex&#x27;, &#x27;age&#x27;]values = [&#x27;tim&#x27;, &#x27;male&#x27;, 23]user = dict(zip(keys, values))print(user)\n打印输出：\n\n{‘name’: ‘tim’, ‘sex’: ‘male’, ‘age’: 23}\n\n7.遍历字典key和value\nuser = &#123;&#x27;name&#x27;: &#x27;tim&#x27;, &#x27;sex&#x27;: &#x27;male&#x27;, &#x27;age&#x27;: 23&#125;for key, value in user.items():\tprint(&#x27;%s = %s&#x27; % (key, value))\n打印输出：\n\nname &#x3D; timsex &#x3D; maleage &#x3D; 23\n\n8.有效值判断\nname = &#x27;this blog&#x27;langs = [&#x27;zh&#x27;, &#x27;en&#x27;, &#x27;jp&#x27;]user = &#123;&#x27;name&#x27;: &#x27;tim&#x27;, &#x27;sex&#x27;: &#x27;male&#x27;, &#x27;age&#x27;: 23&#125;if name and langs and user:\tprint(&#x27;True&#x27;)\n空字符串、空列表、空字典都会返回False打印输出：\n\nTrue\n\n9.三元运算\n# 第一种写法a = 5b = 1 if a &gt; 0 else 0print(&#x27;b =&#x27;, b)# 第二种写法c = (0, a)[a &gt; 0]print(&#x27;c = &#x27;, c)\n第二种是比较晦涩的写法，其实利用的就是逻辑运算结果真或假，程序本身解释便是1或0，然后按照索引取对应的值打印输出：\n\nb &#x3D; 1c &#x3D;  5\n\n10.打开文件使用with打开文件操作完成后会自动关闭文件，无需手动关闭。\nwith open(&#x27;test.txt&#x27;) as f:\tprint(f.read())\n","categories":["Python"],"tags":["Pythonic"]},{"title":"RabbitMQ Delayed Message","url":"/2020/04/05/rbmq-delayed-msg/","content":"利用自身死信队列特性   设置队列（ Queue TTL）或消息（Per-Message TTL）时，当消息到达队列后在TTL规则指定时间内未被消费时会成为死信，利用DLX特性当消息到达死亡时间且处于队头时，可以自动将其重新转发到另一个Exchange或Routing Key，将其路由到指定处理队列以达到延迟的目的。\n\n   实现步骤：\n\n创建交换机（Exchange）\n设置交换机名称为delay，此名称可自定义，后面参数值与此对应。\n\n创建死信队列\n设置队列参数\n&#123;        &quot;x-queue-type&quot;: &quot;classic&quot;,        &quot;x-dead-letter-exchange&quot;: &quot;delay&quot;,\t// 死信交换机     &quot;x-dead-letter-routing-key&quot;: &quot;delay_key&quot;,\t// 死信路由Key&#125;\n\n  绑定此队列到delay交换机，设置路由routing key为delay。\n\n创建处理队列\n 创建死信处理队列，用于死信消费。\n 绑定次队列到delay交换机，设置路由routing key为delay-key。\n\n生产死信延迟消息\n延迟消息参数有两种，一种是设置队的有效期参数x-expires，另一种是针对消息设置生存时间x-message-ttl。\n延迟时间单位 millisecond\n第一种：\nchannel.basic_publish(    exchange=&quot;delay&quot;,    routing_key=&quot;delay&quot;,    body=&quot;[%s]Send message: Hello World!&quot;    % time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()),    properties=pika.BasicProperties(delivery_mode=2, expiration=&quot;3000&quot;),)\n\n第二种：\nchannel.basic_publish(        exchange=&quot;delayed_exchange&quot;,        routing_key=&quot;delayed-key&quot;,        body=&quot;[%s]Send message: Hello World!&quot;        % time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()),        properties=pika.BasicProperties(delivery_mode=2, headers=&#123;&quot;x-message-ttl&quot;: &quot;3000&quot;&#125;),    )\t\t\n\n缺陷问题：\n​\t\t由于消息队列的先进先出原则，该方法在消息不同生存时间刻度的情况下无法保证准确的及时转发到死信处理队列，当生存时间长的消息到达该队列后，后面生存时间短的消息到达该队列时会被生存时间长的消息阻塞，使其在到达失效时间时无法及时出队。\n到达死亡时间且处于队头。\n\n\n使用延迟消息插件   使用延迟消息扩展插件：rabbitmq-delayed-message-exchange，该扩展插件能够针对不同生存时间刻度的消息进行排序，以保证生存时间短的消息能够及时达到队头进行出队。\n   使用步骤：\n\n安装扩展插件\n下载（Community Plugins）该扩展文件将其放置RabbitMQ扩展目录。\n启用扩展插件：\nrabbitmq-plugins enable rabbitmq_delayed_message_exchange\n\n配置延迟消息类型交换机\n创建交换机时选择类型为：x-delayed-message，设置参数x-delayed-type为direct，绑定消息处理队列即可。\n\n生产延迟消息\n设置消息生存时间参数x-delay，单位毫秒。\nchannel.basic_publish(        exchange=&quot;delayed_exchange&quot;,        routing_key=&quot;delayed-key&quot;,        body=&quot;[%s]Send message: Hello World!&quot;        % time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()),        properties=pika.BasicProperties(delivery_mode=2, headers=&#123;&quot;x-delay&quot;: &quot;3000&quot;&#125;),    )\n\n不同时间刻度的消息能够在其失效时及时出队。\n\n\n","categories":["每日一记"],"tags":["MQ","消息队列"]},{"title":"This Blog README","url":"/2020/04/05/readme/","content":"介绍本项目是使用Python语言开发的Blog网站。后端使用的是Django框架，前段使用的是Foundation JavaScript库。仓库地址：https://github.com/WsWHL/blog\n\n环境\n开发工具：vs code\n数据库：my sql\n缓存：redis\n代理：nginx\nPython &gt;&#x3D; 3.7.2Django &gt;&#x3D; 2.1.6Foundation &gt;&#x3D; 6.5\n\n\n\n开发export SECRET_KEY=******python manage.py runserver 8000\n\n开发工具vs code运行时会自动读取根目录下的.env环境变量文件，该文件中配置了必要的一些配置信息，不配置会使用默认值。出于安全考虑，SECRET_KEY只使用环境变量配置，该配置生成方式可参阅Django官方文档。\n\n部署\n系统：centos\n服务：wsgi\n代理：nginx\n容器：docker\n\n编译镜像构建工具docker-compose\ndocker-compose build\n启动容器docker-compose up -ddocker-compose top # 查看运行中的容器状态\n\n-d 将进程放入后台执行\n\n\n默认配置了ssl证书，相关配置参见根目录下的nginx文件夹中的nginx.conf配置文件。\n\n","categories":["Deploy"],"tags":["Blog","README"]},{"title":"常用排序算法锦集","url":"/2020/04/05/sorts/","content":"随机数组使用numpy生成一维随机数组。\nfrom numpy import randomprint(random.randint(100, size=20))\n输出：\n\n[96 53 14 44 39  0 93  2 59 69 22 56 44 81 98  6 93 81 42 34]\n\n\n冒泡排序冒泡排序是指从第一个元素开始，依次与后面的元素比较，如果比其大就进行交换。直到每个元素遍历比较完成为止。\n算法：\ndef sort(arrs):    &quot;&quot;&quot;冒泡排序&quot;&quot;&quot;    length = len(arrs)    if length == 0 or length &lt; 2:        return arrs        for i in range(length):        for j in range(i + 1, length):            if(arrs[i] &gt; arrs[j]):                arrs[i], arrs[j] = arrs[j], arrs[i]\t\t\t\t    return arrs\n\n选择排序选择排序是指假设第一个元素为最小，依次与后面元素比较，找出其中最小值的索引，然后与其进行交换。直到每个元素遍历比较完成为止。\n算法：\ndef sort(arrs):    &quot;&quot;&quot;选择排序&quot;&quot;&quot;    if arrs is None or len(arrs) &lt; 2:        return arrs        for i, num in enumerate(arrs):        min = i        for j in range(i + 1, len(arrs)):            if arrs[j] &lt; arrs[min]:                min = j        if min != i and arrs[min] &lt; num:            arrs[i], arrs[min] = arrs[min], arrs[i]                return arrs\n\n插入排序插入排序是指从第二个元素开始，依次与其前面的元素，从右到左顺序比较，如果比其大则插入到对应元素前面去，交换对应索引继续与前面元素以此比较。\n算法：\ndef sort(arrs):    &quot;&quot;&quot;插入排序&quot;&quot;&quot;    if arrs is None or len(arrs) &lt;= 0:        return []        for i in range(1, len(arrs)):        for j in reversed(range(i)):            if arrs[i] &lt; arrs[j]:                arrs[i], arrs[j] = arrs[j], arrs[i]                i = j        return arrs\n\n\n不同算法之间由于其时间复杂度不同，其性能也有所差异。\n\n","categories":["算法"],"tags":["sort"]},{"title":"Kubernetes This Blog","url":"/2020/04/05/thisblog-k8s/","content":"集群部署环境说明本文采用gcp云服务部署方案，1 个 vCPU，3.75 GB，单节点部署。\n\n所需部署服务说明\nmysql, 有状态服务，用于数据持久化存储\nredis，主要用于文章数据缓存，以此提升网站响应速度\nnginx, 用于网站中静态文件发布服务器，与后端服务站点分离以此达到分流效果\nweb, 后端站点发布服务\ningress controller, 路由控制器，实现站点请求路由，以及站点tls配置\n\n部署#PersistentVolumeClaim\n创建持久化存储卷，有效避免数据丢失。\n\n\nmysql pvc\n  apiVersion: v1kind: PersistentVolumeClaimmetadata:  name: blog-volumeclaimspec:  accessModes:\t- ReadWriteOnce  resources:\trequests:\t  storage: 2Gi\nstatic file pvc\n  apiVersion: v1kind: PersistentVolumeClaimmetadata:  name: blog-static-volumeclaimspec:  accessModes:\t- ReadWriteOnce  resources:\trequests:\t  storage: 100Mi\nmedia file pvc\n  apiVersion: v1kind: PersistentVolumeClaimmetadata:  name: blog-media-volumeclaimspec:  accessModes:\t- ReadWriteOnce  resources:\trequests:\t  storage: 512Mi\n\n#ingress controller\n使用helm添加nginx ingress仓库地址helm repo add stable https://kubernetes-charts.storage.googleapis.com\n\n编写nginx ingress controller配置\n controller:  kind: Deployment  replicaCount: 1  updateStrategy: \trollingUpdate:\t  maxUnavailable: 1\ttype: RollingUpdate  ingressClass: nginx  service:\tenabled: true\tenableHttp: true\tenableHttps: true\ttype: LoadBalancer  resources:\trequests:\t  cpu: 20m\t  memory: 64Mi\tlimits:\t  cpu: 50m\t  memory: 256Mi  defaultBackendService: default/web-servicedefaultBackend:  enabled: falserbac:  create: true\n *** 这里的默认后台服务我是写的自己的站点，格式为namespace&#x2F;service***\n\n安裝nginx ingress controller服务helm install nginx-ingress stable/nginx-ingress -f values.yaml\n\n\n#mysql\ndeployment\n  apiVersion: apps/v1kind: Deploymentmetadata:  name: mysqlspec:  selector:\tmatchLabels:\t  app: mysql  strategy:\ttype: Recreate  template:\tmetadata:\t  labels:\t\tapp: mysql\tspec:\t  containers:\t  - name: mysql\t\timage: mysql:latest\t\targs:\t\t- &quot;--default-authentication-plugin=mysql_native_password&quot;\t\tenv:\t\t- name: MYSQL_DATABASE\t\t  value: &quot;blog&quot;\t\t- name: MYSQL_USER\t\t  value: &quot;root&quot;\t\t- name: MYSQL_ROOT_PASSWORD\t\t  value: &quot;123456&quot;\t\tports:\t\t- containerPort: 3306\t\t  name: mysql\t\tvolumeMounts:\t\t- name: mysql-persistent-storage\t\t  mountPath: /var/lib/mysql\t\tresources:\t\t  requests:\t\t\tcpu: 50m\t\t\tmemory: 512Mi\t  volumes:\t  - name: mysql-persistent-storage\t\tpersistentVolumeClaim:\t\t  claimName: mysql-volumeclaim\nservice\n  apiVersion: v1kind: Servicemetadata:  name: mysql-servicespec:  type: ClusterIP  ports:  - port: 3306  selector:\tapp: mysql\n\n#redis\ndeployment\n  apiVersion: apps/v1kind: Deploymentmetadata:  name: redis-serverspec:  selector:\tmatchLabels:\t  app: redis-server  replicas: 1  template:\tmetadata:\t  labels:\t\tapp: redis-server\tspec:\t  containers:\t  - name: redis-server\t\timage: redis:latest\t\tports:\t\t- containerPort: 6379\t\tresources:\t\t  requests:\t\t\tcpu: 10m\t\t\tmemory: 100Mi\t\t  limits:\t\t\tcpu: 10m\t\t\tmemory: 128Mi\n\nservice\n  apiVersion: v1kind: Servicemetadata:  name: redis-servicespec:  type: NodePort  ports:  - port: 6379  selector:\tapp: redis-serve\n\n#nginx\ndeployment\n  apiVersion: apps/v1kind: Deploymentmetadata:  name: nginx-serverspec:  selector:\tmatchLabels:\t  app: nginx-server  replicas: 1  template:\tmetadata:\t  labels:\t\tapp: nginx-server\tspec:\t  volumes:\t  - name: nginx-volume\t\tconfigMap:\t\t  name: nginx-config\t\t  items:\t\t  - key: nginx.conf\t\t\tpath: nginx.conf\t  - name: blog-static-storage\t\tpersistentVolumeClaim:\t\t  claimName: blog-static-volumeclaim\t  - name: blog-media-storage\t\tpersistentVolumeClaim:\t\t  claimName: blog-media-volumeclaim\t  containers:\t  - name: nginx-server\t\timage: nginx:latest\t\tports:\t\t- containerPort: 80\t\tresources:\t\t  requests:\t\t\tcpu: 20m\t\t\tmemory: 256Mi\t\tvolumeMounts:\t\t- mountPath: /etc/nginx/conf.d\t\t  name: nginx-volume\t\t- name: blog-static-storage\t\t  mountPath: /usr/src/app/web/static\t\t- name: blog-media-storage\t\t  mountPath: /usr/src/app/web/media\n  ** 需要创建nginx.conf configmap配置。*\n\nservice\n  apiVersion: v1kind: Servicemetadata:  name: nginx-service  labels:\tapp: nginx-servicespec:  type: NodePort  ports:  - port: 80\ttargetPort: 80\tprotocol: TCP\tname: http  selector:\tapp: nginx-server\n\n#web\ndeployment\n  apiVersion: apps/v1kind: Deploymentmetadata:  name: webspec:  selector: \tmatchLabels:\t  app: web  replicas: 3  strategy:\ttype: RollingUpdate\trollingUpdate:\t  maxSurge: 25%\t  maxUnavailable: 25%  minReadySeconds: 3  template:\tmetadata:\t  labels:\t\tapp: web\tspec:\t  containers:\t  - name: web\t\timage: asia.gcr.io/whl-vps/blog_web:latest\t\tcommand: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;python manage.py rebuild_index --noinput; uwsgi -i uwsgi.ini&quot;]\t\tenv:\t\t- name: DEBUG\t\t  value: &quot;0&quot;\t\t- name: DOMAIN\t\t  value: &quot;*&quot;\t\t- name: EMAIL_USER\t\t  value: &quot;9239****@qq.com&quot;\t\t- name: EMAIL_PASSWORD\t\t  value: &quot;*****&quot;\t\t- name: EMAIL_PORT\t\t  value: &quot;587&quot;\t\t- name: MYSQL_HOST\t\t  value: &quot;mysql-service&quot;\t\t- name: MYSQL_PORT\t\t  value: &quot;3306&quot;\t\t- name: MYSQL_DATABASE\t\t  value: &quot;blog&quot;\t\t- name: REDIS_HOST\t\t  value: &quot;redis-service&quot;\t\t- name: REDIS_PORT\t\t  value: &quot;6379&quot;\t\t- name: REDIS_DB\t\t  value: &quot;0&quot;\t\t- name: SECRET_KEY\t\t  value: &quot;*****&quot;\t\tports:\t\t- containerPort: 8000\t\t  protocol: TCP\t\tresources:\t\t  requests:\t\t\tcpu: 10m\t\t\tmemory: 128Mi\t\tvolumeMounts:\t\t- name: blog-static-storage\t\t  mountPath: /usr/src/app/web/static\t\t- name: blog-media-storage\t\t  mountPath: /usr/src/app/web/media\t  volumes:\t  - name: blog-static-storage\t\tpersistentVolumeClaim:\t\t  claimName: blog-static-volumeclaim \t  - name: blog-media-storage\t\tpersistentVolumeClaim:\t\t  claimName: blog-media-volumeclaim\n\nservice\n  apiVersion: v1kind: Servicemetadata:  name: web-servicespec:  type: NodePort  ports:  - port: 80\ttargetPort: 8000\tprotocol: TCP  selector:\tapp: web\n\ningress\n  apiVersion: extensions/v1beta1kind: Ingressmetadata:  name: web-ingress  annotations:\tkubernetes.io/ingress.class: nginx\tingress.kubernetes.io/rewrite-target: /\tnginx.ingress.kubernetes.io/from-to-www-redirect: &quot;true&quot;\tnginx.ingress.kubernetes.io/ssl-passthrough: &quot;true&quot;\tnginx.ingress.kubernetes.io/force-ssl-redirect: &quot;true&quot;spec:  tls:  - hosts:\t- www.thisblog.cn\tsecretName: tls-secret  rules:  - host: www.thisblog.cn\thttp:\t  paths:\t  - path: /\t\tbackend:\t\t  serviceName: web-service\t\t  servicePort: 80\t  - backend:\t\t  serviceName: nginx-service\t\t  servicePort: 80\t\tpath: /static\t  - backend:\t\t  serviceName: nginx-service\t\t  servicePort: 80\t\tpath: /media\n\ntls-secret\n  apiVersion: v1kind: Secretmetadata:  name: tls-secretdata:  tls.crt: &lt;base64&gt;  tls.key: &lt;base64&gt;\n  *** base64编码命令，cat thisblog.cn.key | base64 or cat thisblog.cn.crt | base64 ***\n\n\n","categories":["Deploy"],"tags":["Blog","README","YAML"]},{"title":"Trojan服务部署","url":"/2020/04/05/trojan-server/","content":"trojan-gfwtrojan-gfw\n\n\nconfig\n  &#123;\t&quot;run_type&quot;: &quot;server&quot;,\t&quot;local_addr&quot;: &quot;0.0.0.0&quot;,\t&quot;local_port&quot;: 443,\t&quot;remote_addr&quot;: &quot;trojan-nginx&quot;,\t&quot;remote_port&quot;: 80,\t&quot;password&quot;: [\t\t&quot;mypassword&quot;\t],\t&quot;log_level&quot;: 1,\t&quot;ssl&quot;: &#123;\t\t&quot;cert&quot;: &quot;/cers/tls.crt&quot;,\t\t&quot;key&quot;: &quot;/cers/tls.key&quot;,\t\t&quot;key_password&quot;: &quot;&quot;,\t\t&quot;cipher&quot;: &quot;ECDHE-ECDSA-AES128-GCM-SHA256****&quot;,\t\t&quot;cipher_tls13&quot;: &quot;TLS_AES_128_GCM_SHA256***&quot;,\t\t&quot;prefer_server_cipher&quot;: true,\t\t&quot;alpn&quot;: [\t\t\t&quot;http/1.1&quot;\t\t],\t\t&quot;reuse_session&quot;: true,\t\t&quot;session_ticket&quot;: false,\t\t&quot;session_timeout&quot;: 600,\t\t&quot;plain_http_response&quot;: &quot;&quot;,\t\t&quot;curves&quot;: &quot;&quot;,\t\t&quot;dhparam&quot;: &quot;&quot;\t&#125;,\t&quot;tcp&quot;: &#123;\t\t&quot;prefer_ipv4&quot;: false,\t\t&quot;no_delay&quot;: true,\t\t&quot;keep_alive&quot;: true,\t\t&quot;reuse_port&quot;: false,\t\t&quot;fast_open&quot;: false,\t\t&quot;fast_open_qlen&quot;: 20\t&#125;,\t&quot;mysql&quot;: &#123;\t\t&quot;enabled&quot;: false,\t\t&quot;server_addr&quot;: &quot;trojan_db&quot;,\t\t&quot;server_port&quot;: 3306,\t\t&quot;database&quot;: &quot;trojan&quot;,\t\t&quot;username&quot;: &quot;trojan&quot;,\t\t&quot;password&quot;: &quot;123456&quot;\t&#125;&#125;\n\n** 将tls证书放置/cers/目录*\nnginx\n安装nginx软件包yum install nginx -y\n\n启动nginx服务\n  systemctl enable nginxsystemctl start nginx\n\ntrojan service创建服务配置文件vim /etc/systemd/system/trojan.service\n\n服务配置\n  [Unit]Description=trojanDocumentation=man:trojan(1) https://trojan-gfw.github.io/trojan/config https://trojan-gfw.github.io/trojan/After=network.target[Service]Type=simpleStandardError=journalUser=nobodyAmbientCapabilities=CAP_NET_BIND_SERVICEExecStart=/usr/bin/trojan -c /etc/trojan/config.jsonExecReload=/bin/kill -HUP $MAINPIDRestart=on-failureRestartSec=3s[Install]WantedBy=multi-user.target\n\n服务启动命令\n  systemctl enable trojansystemctl start trojan\n\n","categories":["科学上网"],"tags":["Trojan","Proxy"]},{"title":"v2ray工具配置教程","url":"/2020/04/05/v2ray-server/","content":"\n常说授人以鱼不如授人以渔，本文主要讲解关于Linux系统下如何配置v2ray工具，假定你是一个拥有Linux基础的用户，且动手能力强，生命在于折腾。\n本文采用docker容器安装方式，至于为何如此，我想你懂的。\n\n工具准备\n购买VPS或ECS。前段时间买了国外几个服务商的试用了一下，总所周知的几个服务商的都不能用，后来选了一个小众 的折腾了一下，虽然勉强能用，但毕竟横跨太平洋，远程操作时那叫一个卡。后来报着试一试的态度买了阿里云香港的VPS。当然使用前考虑到毕竟是国内服务商，想必一定很严格，查了一下网上各种中奖。因此觉得常规的方式定然行不通，于是便想到了用docker试一试又何尝不可，毕竟容器单独隔离。只是运行v2ray工具，一台小鸡足矣，配置如下：\n\n内存1GCPU 1核磁盘25G流量1T带宽30Mbps系统Centos 7\n\n\n拉取v2ray镜像。由于采用docker安装，首先得安docker软件。\nyum install docker  # 安装dockersystemctl enable docker  # 设置开机启动systemctl start docker  # 启动服务\n国内用户docker拉取镜像时通常会很慢，这时我们得修改仓库地址为国内地址。在这里我们使用的是香港的服务器，自然也就不存在慢的情况了。\ndocker pull v2ray/official   # 拉取镜像\n\n创建配置文件。在VPS系统/etc/v2ray/目录创建配置文件config.json，写入以下格式内容。\n&#123;  &quot;log&quot;: &#123;    &quot;access&quot;: &quot;/var/log/v2ray/access.log&quot;,    &quot;error&quot;: &quot;/var/log/v2ray/error.log&quot;,    &quot;loglevel&quot;: &quot;warning&quot;  &#125;,  &quot;dns&quot;: &#123;\t&quot;ip&quot;:&quot;8.8.8.8&quot;,\t&quot;port&quot;:53,\t&quot;isDNS&quot;:true  &#125;,  &quot;stats&quot;: &#123;&#125;,  &quot;inbounds&quot;: [    &#123;      &quot;protocol&quot;: &quot;vmess&quot;,      &quot;settings&quot;: &#123;        &quot;clients&quot;: [          &#123;            &quot;alterId&quot;: ***,            &quot;id&quot;: &quot;***&quot;          &#125;        ]      &#125;,      &quot;port&quot;: ***,      &quot;streamSettings&quot;: &#123;        &quot;tcpSettings&quot;: &#123;&#125;,        &quot;network&quot;: &quot;tcp&quot;,        &quot;security&quot;: &quot;auto&quot;      &#125;,      &quot;tag&quot;: &quot;in-0&quot;    &#125;  ],  &quot;outbounds&quot;: [    &#123;      &quot;tag&quot;: &quot;direct&quot;,      &quot;protocol&quot;: &quot;freedom&quot;,      &quot;settings&quot;: &#123;&#125;    &#125;,    &#123;      &quot;tag&quot;: &quot;blocked&quot;,      &quot;protocol&quot;: &quot;blackhole&quot;,      &quot;settings&quot;: &#123;&#125;    &#125;  ],  &quot;routing&quot;: &#123;    &quot;domainStrategy&quot;: &quot;AsIs&quot;,    &quot;rules&quot;: [      &#123;        &quot;outboundTag&quot;: &quot;blocked&quot;,        &quot;ip&quot;: [          &quot;geoip:private&quot;        ],        &quot;type&quot;: &quot;field&quot;      &#125;    ]  &#125;,  &quot;policy&quot;: &#123;&#125;,  &quot;reverse&quot;: &#123;&#125;,  &quot;transport&quot;: &#123;&#125;&#125;\n修改配置中星号内容替换为自己的配置。inbounds.clients.id:uuid格式字符串inbounds.clients.alterId:任意数字编号inbounds.port:当前配置项对应端口号，尽可能四位以上，避免与系统端口冲突。\n\ninbounds:配置中该节点为一个数组对象，也就是说可以有多个配置项，可以是同种协议的，也可以是不同协议的，切记多个配置端口号不能相同，不同协议的配置能容略有差异。协议列表\n\n\n\n启动容器启动方式有多种，可以直接是命令行执行，也可以借用docker-compose工具启动配置好的容器。\n\n命令行直接启动，后台执行且开机自启docker run -d --name v2ray --restart always -v /etc/v2ray:/etc/v2ray -p 16666:8888 -p 16668:8889 -p 16669:8890 v2ray/official v2ray -config=/etc/v2ray/config.json\n\n-d:后台运行–name:容器名称，不能重复–restart:容器会随着服务的启动而启动-v:挂载目录，系统目录:容器中目录，将系统目录/etc/v2ray挂载到容器中的/etc/v2ray目录，这样容器就能直接访问/etc/v2ray下的配置文件，当需要修改配置时直接修改系统目录下配置即可-p:暴露端口，系统端口:容器端口v2ray&#x2F;official:容器启动的镜像v2ray -config&#x3D;&#x2F;etc&#x2F;v2ray&#x2F;config.json:容器执行的命令\n\n\n\n至此工具已经配置完成，请记得检查系统是否已打开相应端口。及检查服务商后台防火墙或安全组是否已允许开放相应端口号，没有就加一下，不然访问不通。安装客户端工具，配置相应配置即可。\n","categories":["科学上网"],"tags":["Proxy","V2ray"]},{"title":"开发中踩过的那些坑...","url":"/2020/04/04/works-bug/","content":"表达式树表达式树以树形数据结构表示代码，其中每一个节点都是一种表达式，逻辑以表达式的方式存储在树状结构里，从而可以在运行时去解析这个树，然后执行，实现动态的编辑和执行代码，在不同数据库中执行 LINQ 查询以及创建动态查询。\n\n1.使用lambda表达式创建表达式树\nExpression&lt;Func&lt;int, int&gt;&gt; expr = num =&gt; num * 2;Func&lt;int, int&gt; result = expr.Compile();Console.Write(result(5));\n打印输出：\n\n10\n\n以上表达式树编译后，返回一个带输入输出参数的委托对象。\n2.使用LINQ查询数据时，传递错误的表达式参数导致数据库全表查询。这里只演示LINQ查询时的核心部分代码。\n\n错误使用：\nFunc&lt;UserInfo, bool&gt; filter = u =&gt; u.Id == 1 &amp;&amp; u.IsDelete == false;var users = dbContext.UserInfos.Where(filter).ToList();\nSQL\n\nSELECT Id, Name… FROM UserInfo\n\n  以上式例中传递的查询条件并非表示式树，而是一个委托对象。虽然编译时编译器并不会报错，但在实际查询时，监控SQL查询语句你会发现查询条件并没有包含在SQL语句中，这样就会导致每次查询时会全表查询，把所有数据加载到内存中，然后使用委托过滤掉。虽然业务实现了，但在大量并发请求时导致的内存消耗无疑是一场灾难。\n\n正确使用：\nExpression&lt;Func&lt;UserInfo, bool&gt;&gt; filter = u =&gt; u.Id == 1 &amp;&amp; u.IsDelete == false;var users = dbContext.UserInfos.Where(filter).ToList();\nSQL\n\nSELECT Id, Name… FROM UserInfo WHERE Id &#x3D; 1 AND IsDelete &#x3D; 0\n\n\n\nUri.EscapeDataString\n.Net HttpClient Invalid URI: The Uri string is too long\n\n在使用HttpClient通过Post发送大量数据请求时，报错“无效的URI：Uri字符串太长”，由于转义字符串超过最大长度限制。不同版本（.NET）限制长度：\n\n\n\n版本\n限制长度\n有效长度\n\n\n\n&lt; 4.5\n32766\n32765\n\n\n&gt;&#x3D; 4.5\n65520\n65519\n\n\n解决方案：\npublic static string EncodeString(string content)&#123;    // maxLengthAllowed .NET &lt; 4.5 = 32765;    // maxLengthAllowed .NET &gt;= 4.5 = 65519;    int maxLengthAllowed = 65519;    StringBuilder sb = new StringBuilder();\tint loops = content.Length / maxLengthAllowed;\t\tfor(int i = 0; i &lt;= loops; i++)&#123;\t\tsb.Append(Uri.EscapeDataString(i &lt; loops \t\t? content.Substring(i * maxLengthAllowed, maxLengthAllowed)\t\t: content.Substring(i * maxLengthAllowed)\t\t));\t\t\t\treturn sb.ToString();\t&#125;&#125;\n使用Post发送对象数据时，content格式为“key&#x3D;value&amp;key1&#x3D;value1&amp;….”\n","categories":["C#"],"tags":["debug"]}]